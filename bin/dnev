#!/usr/bin/env python3

import curses
import os
import sys
import locale
import logging
import subprocess

from dnevnichok.aux import EventQueue
from dnevnichok.helpers import get_config
from dnevnichok.managers import AllManager, FileManager, TagManager
from dnevnichok.ui import ItemList, MainWindow

locale.setlocale(locale.LC_ALL, '')
code = locale.getpreferredencoding()

logging.basicConfig(filename='noter.log')


class App:
    """ App manages main window, managers, process events from underlying UI"""
    def __init__(self, stdscr):
        self.file_manager = FileManager(os.path.abspath(os.path.expanduser(config.get('Paths', 'notes'))))
        self.tag_manager = TagManager(os.path.abspath(os.path.expanduser(config.get('Paths', 'db'))))
        self.all_manager = AllManager(os.path.abspath(os.path.expanduser(config.get('Paths', 'db'))))
        self.manager = self.file_manager        # current manager
        items = self.manager.get_items()
        self.window = MainWindow(stdscr)
        self.window.show_items(items)
        self.processors = {'open': self.process_open,
                           'root': self.process_root,
                           'parent': self.process_parent}
        self.loop()

    def loop(self):
        while True:
            ev = EventQueue.pop()
            self.process_event(ev)
            c = self.window.stdscr.get_wch()

            self.window.clear_bar()
            if not self.window.process_keypress(c):
                signal = self.process_keypress(c)
                if signal == 'exit':
                    break

    # Event-processing part
    def process_event(self, e):
        if e[0]: self.processors[e[0]](e)

    def process_parent(self, ev):
        last_active = self.manager.parent()
        if not last_active:
            return
        items = self.manager.get_items()
        last_active_index = items.index({'full_path': last_active, 'title': last_active})
        self.window.show_items(items, last_active_index)

    def process_open(self, ev):
        path = ev[1]['full_path']
        title = ev[1]['title']
        if path == '..':
            self.process_parent(ev)
            return
        if os.path.isdir(path):
            self.manager.chpath(path)
            dir_items = self.manager.get_items()
            self.window.show_items(dir_items)
        else:
            if path.endswith('.rst'):
                subprocess.call(["vi", path])
                self.manager.chpath('.')
                items = self.manager.get_items()
                self.window.show_items(items)
            else:
                self.manager.chpath(path)
                items = self.manager.get_items()
                self.window.show_items(items)

    def process_root(self, event):
        self.manager.root()
        items = self.manager.get_items()
        self.window.show_items(items)

    def process_keypress(self, c):
        """ May return a text signal to mainloop """
        if type(c) is not str:
            return
        if c in 'r':    # if populate_db(c)
            from dnevnichok.populate import repopulate_db
            repopulate_db()
        elif c in 'QqЙй':
            return 'exit'
        elif c in 'f':      # MANAGER   if switch_manager(c): return
                            # switch_manager knows about keybindings
            if self.manager is self.file_manager:
                return
            self.manager = self.file_manager
            EventQueue.push(('root',))
        elif c in 'a':      # MANAGER
            if self.manager is self.all_manager:
                return
            self.manager = self.all_manager
            EventQueue.push(('root',))
        elif c in 't':      # MANAGER
            if self.manager is self.tag_manager:
                return
            self.manager = self.tag_manager
            EventQueue.push(('root',))
        elif c in '/':
            search = self.window.input('/ ')
            new_items = list(filter(lambda q: q['title'].find(search) >= 0, self.manager.get_items()))
            count = len(new_items)
            if count > 0:
                self.window.show_items(new_items)
                self.window.print("{} items found".format(count))
            else:
                self.window.print("Nothing found")


if __name__ == '__main__':
    config = get_config()
    curses.wrapper(App)
    print("Closing dnevnichok. See you later.")
    sys.exit(0)
