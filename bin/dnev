#!/usr/bin/env python3

import curses
import os
import sys
import locale
import logging
import subprocess

from dnevnichok.aux import EventQueue
from dnevnichok.core import Item, NoteItem, DirItem, TagItem
from dnevnichok.helpers import get_config
from dnevnichok.managers import AllManager, FileManager, TagManager
from dnevnichok.ui import ItemList, MainWindow

locale.setlocale(locale.LC_ALL, '')
code = locale.getpreferredencoding()

logging.basicConfig(filename='noter.log')

try:
    import colored_traceback
    colored_traceback.add_hook()
except ImportError:
    pass


class App:
    """ App manages main window, managers, process events from underlying UI"""
    def __init__(self, stdscr):
        dbpath = os.path.abspath(os.path.expanduser(config.get('Paths', 'db')))
        notespath = os.path.abspath(os.path.expanduser(config.get('Paths', 'notes')))
        os.chdir(notespath)

        self.file_manager = FileManager(1, dbpath)
        self.tag_manager = TagManager(dbpath)
        self.all_manager = AllManager(dbpath)
        self.manager = self.file_manager        # current manager
        items = self.manager.get_items()
        self.window = MainWindow(stdscr)
        self.window.show_items(items)
        self.processors = {'open': self.process_open,
                           'root': self.process_root,
                           'parent': self.process_parent}
        self.loop()

    def loop(self):
        while True:
            ev = EventQueue.pop()
            self.process_event(ev)
            c = self.window.stdscr.get_wch()

            self.window.clear_bar()
            if not self.window.process_keypress(c):
                signal = self.process_keypress(c)
                if signal == 'exit':
                    break

    # Event-processing part
    def process_event(self, e):
        if e[0]: self.processors[e[0]](e)

    def process_parent(self, ev):
        last_active = self.manager.parent()
        if not last_active:
            return
        hint = 'tag' if self.manager is self.tag_manager else None
        items = self.manager.get_items()
        last_active_index = items.index(Item(last_active, hint))
        self.window.show_items(items, last_active_index)

    def process_open(self, ev):
        item = ev[1]
        if isinstance(item, (DirItem, TagItem,)):
            self.manager.chpath(item.id)
        elif isinstance(item, NoteItem):
            subprocess.call(["vi", item.get_path()])

        items = self.manager.get_items()
        self.window.show_items(items)

    def process_root(self, event):
        items = self.manager.get_items()
        self.window.show_items(items)

    def process_keypress(self, c):
        """ May return a text signal to mainloop """
        if type(c) is not str:
            return
        if c in 'r':    # if populate_db(c)
            from dnevnichok.populate import repopulate_db
            repopulate_db()
        elif c in 'QqЙй':
            return 'exit'
        elif c in 'f':      # MANAGER   if switch_manager(c): return
                            # switch_manager knows about keybindings
            if self.manager is self.file_manager:
                return
            self.manager = self.file_manager
            EventQueue.push(('root',))
        elif c in 'a':      # MANAGER
            if self.manager is self.all_manager:
                return
            self.manager = self.all_manager
            EventQueue.push(('root',))
        elif c in 't':      # MANAGER
            if self.manager is self.tag_manager:
                return
            self.manager = self.tag_manager
            EventQueue.push(('root',))
        elif c in '/':
            search = self.window.input('/ ')
            new_items = list(filter(lambda q: q.title.find(search) >= 0, self.manager.get_items()))
            count = len(new_items)
            if count > 0:
                self.window.show_items(new_items)
                self.window.print("{} items found".format(count))
            else:
                self.window.print("Nothing found")


if __name__ == '__main__':
    config = get_config()
    curses.wrapper(App)
    print("Closing dnevnichok. See you later.")
    sys.exit(0)
