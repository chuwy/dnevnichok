#!/usr/bin/env python3

import curses
import os
import sys
import locale
import logging

from dnevnichok.commands import get_all_commands, InsufficientArguments
from dnevnichok.config import Config, setup_logging
from dnevnichok.events import event_hub
from dnevnichok.managers import ManagerHub
from dnevnichok.populate import repopulate_db
from dnevnichok.ui import MainWindow

locale.setlocale(locale.LC_ALL, '')
code = locale.getpreferredencoding()
config = Config()

try:
    import colored_traceback
    colored_traceback.add_hook()
except ImportError:
    pass


class Executor:
    """
    Responsible for take find all available commands, pick right one and
    give it everything it needs. Also stores history.
    """
    def __init__(self, app):
        self.app = app
        self.commands = get_all_commands()

    def run_command(self, command: str):
        command, *args = command.split()
        try:
            CommandClass = self.commands[command]
        except KeyError:
            event_hub.trigger(('print', "Unknown command: " + command))
            return

        try:
            execution = CommandClass(self, args)
        except InsufficientArguments as e:
            event_hub.trigger(('print', e.message))
            return

        proceed = execution.ensure()
        if proceed:
            execution.run()

    def ensure(self, text, tries=0):
        choice = self.app.window.input(text)
        if choice in 'yY':
            return True
        elif choice in 'nN':
            return False
        elif tries > 3:
            event_hub.trigger(('print', "Ok. Just have a good day"))
            return False
        else:
            return self.ensure(text, tries+1)

    def get_current_item(self):
        return self.app.window.get_current_item()


class App:
    """ App manages main window, managers, process events from underlying UI"""
    def __init__(self, stdscr):
        dbpath = config.get_path('db')
        notespath = config.get_path('notes')
        os.chdir(notespath)
        if not os.path.exists(dbpath):
            repopulate_db()

        self.executor = Executor(self)
        self.manager_hub = ManagerHub()
        items = self.manager_hub.active.get_items()
        self.window = MainWindow(stdscr)
        self.window.show_items(items)
        self.keystack = []   # for gg (move to first element) and numerical

        event_hub.register('key-press', self.process_keypress)
        event_hub.register('exit', self.exit)

        self._running = False
        self.run_forever()

    def run_forever(self):
        self._running = True
        while self._running:
            try:
                c = self.window.stdscr.get_wch()
            except KeyboardInterrupt:
                event_hub.trigger(('exit',))
            else:
                self.window.clear_bar()
                event_hub.trigger(('key-press', c))

    def process_keypress(self, c):
        if type(c) is not str:
            return

        def filter_items(query):
            items = self.manager_hub.active.get_items()
            return [item for item in items if item.title.find(query) > -1]

        if not self.keystack:
            if c in 'QqЙй': event_hub.trigger(('exit',))
            elif c in 'Rr':
                repopulate_db()
            elif c in '/':
                query = self.window.input('/ ')
                event_hub.trigger(('show', filter_items(query)))
            elif c in ':':
                command = self.window.input(': ')
                self.executor.run_command(command)
            elif c in 'gп' or c.isnumeric():
                self.keystack.append(c)
            elif self.manager_hub.tied_to_manager(c):
                self.manager_hub.switch_by_key(c)
        else:
            if c in 'gп':
                if self.keystack[0] in 'gп':
                    self.window.left_pane.move_to(0)
                if self.keystack[-1].isnumeric():
                    elem_num = ''.join(self.keystack)
                    self.window.left_pane.move_to(int(elem_num)-1)
            if c.isnumeric():
                self.keystack.append(c)
            else:
                self.keystack = []

    def exit(self):
        self._running = False


if __name__ == '__main__':
    setup_logging()
    logger = logging.getLogger(__name__)
    curses.wrapper(App)
    logger.info("Closing dnevnichok. See you later.")
    sys.exit(0)
